// ***************************************************************
// *****      Assembly HSYNC (TIMER0) interrupt vector       *****
// ***** by Carsten Herting (slu4), last update: 17.07.2023  *****
// ***** copy 'os.h' and 'os.S' into '/Arduino/libraries/os' *****
// ***************************************************************

#define __SFR_OFFSET 0x00        // set the Special Function Register Offset from 0x20 to 0x00 in order to use AVR PORT definitions
#include <avr/io.h>              // include PORTB, DDRD, ... symbols for easier register access

.global TIMER0_COMPA_vect        // define this global to make the Arduino IDE integrate the ISR

// ***************************************************************

.macro ONECHAR                   //     Z: address of char data (MSB is fixed, LSB depends on char), X: current VRAM position (one line)
            ld    ZL, X+         // 2CP ZL = (X), X = X + 1
            lpm   r21, Z         // 3CP get font byte from program memory for current chr on current line
            out   PORTD, r21     // 1CP put data to shift register's parallel input
            out   PORTB, r24     // 1CP /PE LOW (next CLK rising edge will load pixel data)
            out   PORTB, r23     // 1CP /PE HIGH (now CLK will pump out 8 pixels)
 .endm

// ***************************************************************

TIMER0_COMPA_vect:               // ISR table entry is automatically generated by the AVR assembler
            push r1              // save r1 and r0 (r0-1 are modified by the result of a multiplication)
            push r0
            in r0, SREG          // reads the AVR status register SREG 0x3f holding the complete flag state
            push r0              // push it on the stack, too

            push  r20            // push content on stack, so we can use this register right away

            lds r20, TCNT2       // interrupt jitter compensation using timer TCNT2
            cpi r20, 4
            breq .+8
            cpi r20, 3
            breq .+6
            cpi r20, 2
            breq .+4
            nop
            nop
            nop
            
            cbi PORTB, 4         // start HSYNC pulse by hand

            push  r21            // push current values of registers to be used onto stack
            push  r22
            push  r23
            push  r24
            push  r25
            push  r26            // X
            push  r27
            push  r30            // Z
            push  r31

            lds r20, vline+0     // lade vline nach r20-21
            lds r21, vline+1
            movw r24, r20        // copy register pair r20/21 -> r24/25
            adiw r24, 1          // erhöhe vline um 1
            sts vline+1, r25     // speichere vline wieder
            sts vline+0, r24
            lsr r21              // divide vline by 2 and subtract 30 ??? lsr also okay??
            ror r20
            subi r20, 30         // r20 = pixel line "lin"

            sbi PORTB, 4         // ??? end HSYNC (after only 1µ, should be 3,8µs but this buys valuable time here)

            in r22, PINC         // r22 = scan PS/2 keyboard state (CLK and DAT) every 32µs
                                 // Note: This is not quite fast enough to cover the full PS/2 spec
                                 // (10.0 - 16.7kHz) but works fine with all PS/2 keyboards I have checked.
            
            mov r21, r20         // calculate VRAM row address from lin
            lsr r21
            lsr r21
            lsr r21              // lin>>3 = row number
						ldi r23, 40
            mul r23, r21         // ATTENTION: calculate * 40 => RESULT is in r0-r1!!!
            movw r30, r0         // RESULT r0-1 to r30-31 (Z): index of VRAM row

            ldi r24, 0           // needed for add with carry (see below)
            ldi XL, lo8(cram)		 // output the row color to pins A2-A5 (C2-C5)
            ldi XH, hi8(cram)
            add XL, r21          // add row number index to start address
            adc XH, r24          // takes a potential carry flag into account
						ld r21, X 					 // load row color from (X)
						lsl r21							 // shift color info 2 steps up to C2..5
						lsl r21
						ori r21, 3					 // make sure the 20k-pull-ups stay always on for PS/2 CLK and DAT
						out PORTC, r21			 // output color information

            ldi XL, lo8(vram)
            ldi XH, hi8(vram)
            add XH, ZH           // add VRAM row index to VRAM start address
            add XL, ZL           // r26-27 = X = VRAM row address
            adc XH, r24          // takes a potential carry flag into account
            
            mov r21, r20         // get lin a 2nd time
            andi r21, 7          // only use lowest 3 bits of lin to determin charset line

            ldi ZH, hi8(charset) // charset must be aligned to 256 bytes
            add ZH, r21          // now ZH points to the charset line

            in r23, PORTB        // prepare the two different /PE states for ultra-fast switching
            mov r24, r23         // r23: B3=1
            andi r24, 0x37       // r24: B3=0

            cpi r20, 200         // draw 200 scanlines (25 x 8)
            brcs drawPixels
              jmp regHandler

drawPixels: ldi r20, 11          // shifts screen left BUT BE CAREFUL: if routine takes too long, it won't fit into a scanline!
wait:       dec r20
            brne wait

            ONECHAR              // transmit 40 characters at a rate of 2MHz (16MHz pixel clock)
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR

            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR

            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR

            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
            ONECHAR
              
regHandler: mov r23, r22
            andi r23, 2              // r23 = isolated DAT in bit1
            andi r22, 1              // r22 = isolated current CLK in bit0, operation sets Z flag
            breq regLow              // CLK = 0?

              lds r30, data+1        // CLK = 1!
              cpi r30, 0             // high byte will contain at least the high stop bit if data is present
              breq regEnd            // don't do anything if no data is present

                lds r30, cnts        // we have data! => Check for end of datagram...
                inc r30
                sts cnts, r30        // cnts++
                cpi r30, 8           // cnts >= 8?
                brlo regEnd

                  ldi ZH, hi8(reg)   // DATAGRAM finished! => prepare Z for an indirect store
									ldi ZL, lo8(reg)
                  lds r21, regin     // load direct from data space: "regin" index
									add ZL, r21
									ldi r21, 0
									adc ZH, r21
									
                  lds r21, data+0    // load low PS/2 data byte (start bit is shifted out)
                  st Z, r21          // store scan code -> (Z)
									
                  lds r30, regin     // again load "regin" index for incrementation
                  inc r30            // regin++
                  andi r30, 7        // only use 8 bytes for KEYBUFSIZE (wrap around)
                  sts regin, r30     // store regin back to data space
                  ldi r30, 0
                  sts data+1, r30    // invalidate the PS/2 data by setting MSB to zero
                  jmp regEnd

  regLow:   lds r21, prev            // CLK = 0! => load previous CLK state
            cp r22, r21           	 // compare the two CLK states for a change
            breq regEnd           	 // CLK falling edge?

              ldi r30, 0
              sts cnts, r30     		 // reset the counter after rising edge
              lds r20, data     		 // load data into r20-21
              lds r21, data+1
              lsr r21           		 // shift data one step down
              ror r20
              or  r21, r23      		 // insert the (previous) DAT as bit9
              sts data+0, r20   		 // store data
              sts data+1, r21

regEnd:     sts prev, r22       		 // remember the state of CLK
            pop r31               	 // restore previous values of used registers
            pop r30               	 // Z
            pop r27
            pop r26               	 // X
            pop r25
            pop r24
            pop r23
            pop r22
            pop r21
            pop r20           
            pop r0                	 // restore the AVR status register SREG 0x3f value
            out SREG, r0          	 // set the SREG back to what it was
            pop r0                	 // restore r0, r1 
            pop r1
            reti                  	 // return from interrupt
/*
	-----------
	MIT License
	-----------
	Copyright (c) 2023 Carsten Herting
	Permission is hereby granted, free of charge, to any person obtaining a copy of
	this software and associated documentation files (the "Software"), to deal in
	the Software without restriction, including without limitation the rights to
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
	of the Software, and to permit persons to whom the Software is furnished to do
	so, subject to the following conditions:
	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/
