#define __SFR_OFFSET 0x00       // set the Special Function Register Offset from 0x20 to 0x00 in order to use the AVR PORT definitions
#include <avr/io.h>             // include PORTB, DDRD, ... symbols for easier register access

.global TIMER0_COMPA_vect       ; define this global to make the Arduino IDE integrate the ISR

.macro TWOCHARS
            ld    ZL, X+          ; 2   ZL = (X), X = X + 1
            lpm   r23, Z          ; 3   get font byte from program memory for current chr on current line
            out   PORTD, r23      ; 1   put data to shift register
            sbi   PORTB, 3        ; 2   pin toggling creates /PL spike via XOR
            ld    ZL, X+          ; 2   ZL = (X), X = X + 1
            lpm   r23, Z          ; 3   get font byte from program memory for current chr on current line
            out   PORTD, r23      ; 1   put data to shift register
            cbi   PORTB, 3        ; 2   pin toggling creates /PL spike via XOR
.endm

; *******************************************************************
; *****                                                         *****
; ***** Assembler routine sending out pixel data for a scanline *****
; *****                                                         *****
; *******************************************************************
TIMER0_COMPA_vect:              ; ISR table entry is automatically generated by the AVR assembler
            push r1             ; save r1 and r0 (the compiler needs this?)
            push r0
            in r0, SREG         ; reads the AVR status register SREG 0x3f holding the complete flag state
            push r0             ; push it on the stack, too
            eor r1, r1          ; r1: 0

            push  r20           ; push content on stack, so we can use this register right away

            lds r20, TCNT2      ; timer TCNT2 jitter compensation
            cpi r20, 4
            breq .+8
            cpi r20, 3
            breq .+6
            cpi r20, 2
            breq .+4
            nop
            nop
            nop

            cbi PORTB, 4        ; start of sync pulse

            push  r21
            push  r22
            push  r23
            push  r24
            push  r25
            push  r26
            push  r27
            push  r30
            push  r31

            out DDRD, r1        ; r1=0: make D6-7 inputs (PORTD ist hier 0 vom Ende der letzten scanline => pull-ups sind aus)

            lds r20, vline      ; lade vline nach r20-21
            lds r21, vline+1
            movw r24, r20       ; copy register pair r20/21 -> r24/25
            adiw r24, 1         ; erhöhe vline um 1
            sts vline+1, r25    ; speichere vline wieder
            sts vline, r24
            asr r21             ; divide vline by 2 and subtract 30
            ror r20
            subi r20, 30        ; r20: Pixellinie "lin", r24: vline

            sbi PORTB, 4        ; end of sync pulse (after 1µ, should be 3,8µs but this buys valuable time here)

            in r23, PIND        ; read in PS/2 keyboard scan code from register 74HC173
            in r22, PINC
            andi r22, 0b00111111
            andi r23, 0b11000000
            or r22, r23					; r22: scan code of keyboard

            ldi r23, 0xff
            out DDRD, r23       ; make D6-7 outputs

            mov r21, r20        ; calculate VRAM row address from lin
            lsr r21
            lsr r21
            lsr r21             ; lin>>3
						ldi r25, 40
            mul r25, r21        ; calculate * 40 => Ergebnis ist in r0-1
            movw r30, r0        ; r30-31 (Z): index of VRAM row
            eor r1, r1          ; r1: 0
            
            ldi XL, lo8(vram)
            ldi XH, hi8(vram)
            add XH, ZH          ; add VRAM row index to VRAM start address
            add XL, ZL
            adc XH, r1          ; r26-27 (X): VRAM row address

            mov r21, r20        ; get lin
            andi r21, 7         ; r21: lin & 7, only use lowest 3 bits of lin to determin charset line

            ldi ZH, hi8(charset); charset must be aligned to 256 bytes
            add ZH, r21         ; now ZH points to the charset line

            cpi r20, 200        
            brcs drawPixels
              jmp regHandler

drawPixels: ldi r23, 12        ; shifts screen left BUT BE CAREFUL: if routine takes too long, it won't fit into a scanline!
wait:       dec r23
            brne wait

            TWOCHARS          ; shift out 20 character pairs
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
            TWOCHARS
              
regHandler: cpi r22, 0							; check for scan != 0
						breq retreat
							andi r24, 7
							cpi r24, 0						; check for lin & 7 == 0 (only every 256µs)
							brne retreat
								lds r23, prev				; load previous scancode
								cp r22, r23					; check scan == prev (was the data stable?)
								brne notstable
									cbi PORTB, 1  		; pulse /MR low
									sbi PORTB, 1
									ldi r31, hi8(reg) ; prepare Z for a load indirect
									lds r30, regin    ; load direct from data space: "regin" index = LSB
									st Z, r22         ; store scan -> (Z)
									inc r30           ; regin++, transfer buffer wraps around
									andi r30, 7				; only use 8 bytes for KEYBUFSIZE
									sts regin, r30    ; store regin back to data space
	notstable:		sts prev, r22				;	prev = scan
retreat:    pop r31
            pop r30
            pop r27
            pop r26
            pop r25
            pop r24
            pop r23
            pop r22
            pop r21
            pop r20
            pop r0        ; restore the AVR status register SREG 0x3f value
            out SREG, r0  ; set the SREG back to what it was
            pop r0        ; restore r0, r1 
            pop r1
            reti          ; return from interrupt
/*
-----------
MIT License
-----------
Copyright (c) 2021 Carsten Herting
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/*     
  ISR(TIMER0_COMPA_vect)          // HSYNC generation and drawing of a scanline
  {
    asm("lds  r24, 0x00B2\n"      // compensate interrupt jitter
        "cpi  r24, 0x06\n"
        "breq .+8\n"
        "cpi  r24, 0x05\n"
        "breq .+6\n"
        "cpi  r24, 0x04\n"
        "breq .+4\n"
        "nop\n"
        "nop\n"
        "nop\n" );

    DDRD  = 0b00000000;                                     // D = input
    PORTB = 0b00000010;                                     // /HSYNC=0, /MR=1
    byte lin = ((vline++) >> 1) - 30;                       // skip 2 lines (VSYNC pulse) + some lines (vertical back porch)
    volatile byte* vrow = vram[lin >> 3];                   // pointer to the vram row 0...24 to display
    volatile byte* cset = charset[lin & 0b111] - 32;          // pointer to the charset line 0..7 to use starting @ character 32
    byte scan = (PINC & 0b00111111) | (PIND & 0b11000000);  // read only after output has stabilized
    PORTB = 0b00010010;                                     // /HSYNC=1, /MR=1
    DDRD  = 0b11111111;                                     // D = output

    __builtin_avr_delay_cycles(4);// shift the whole picture to the right
  
    if (lin < ROWS*8)             // draw a line of pixels
    {  
      TCCR2A &= ~(1<<COM2A1);     // enable OC2A toggling pin 11          
      PORTD = cset[*vrow++];      // send 40 bytes
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      PORTD = cset[*vrow++];
      TCCR2A |= (1<<COM2A1);      // stop any further parallel load /PE (disabling OC2A toggling pin 11)
      PORTD = 0;
    }
    
    static byte prev = 0;         // remember the previous valid keyboard scan code
    if (scan != 0)
    {
      if ((vline & 7) == 0)       // every 256µs the 74HC173 keyboard register is sampled
      {
        if(scan == prev)          // was the data stable?
        {
          PORTB = 0b00010000;     // /HSYNC=1, /MR=0 
          PORTB = 0b00010010;     // /HSYNC=1, /MR=1 
          reg[regin++] = scan;    // queue of register data
          regin &= (KEYBUFSIZE-1);
        }
        prev = scan;
      }
    }
  }
*/
